import { JSONObject } from '../algorithm/json';
import { ISequence } from '../algorithm/sequence';
import { IDisposable } from '../core/disposable';
import { ISignal } from '../core/signaling';
import { IKeyboardLayout } from './keyboard';
/**
 * An object which holds the results of parsing a keystroke.
 */
export interface IKeystrokeParts {
    /**
     * Whether `'Cmd'` appears in the keystroke.
     */
    cmd: boolean;
    /**
     * Whether `'Ctrl'` appears in the keystroke.
     */
    ctrl: boolean;
    /**
     * Whether `'Alt'` appears in the keystroke.
     */
    alt: boolean;
    /**
     * Whether `'Shift'` appears in the keystroke.
     */
    shift: boolean;
    /**
     * The primary key for the keystroke.
     */
    key: string;
}
/**
 * Parse a keystroke into its constituent components.
 *
 * @param keystroke - The keystroke of interest.
 *
 * @returns The parsed components of the keystroke.
 *
 * #### Notes
 * The keystroke should be of the form:
 *   `[<modifier 1> [<modifier 2> [<modifier N> ]]]<primary key>`
 *
 * The supported modifiers are: `Accel`, `Alt`, `Cmd`, `Ctrl`, and
 * `Shift`. The `Accel` modifier is translated to `Cmd` on Mac and
 * `Ctrl` on all other platforms.
 *
 * The parsing is tolerant and will not throw exceptions. Notably:
 *   - Duplicate modifiers are ignored.
 *   - Extra primary keys are ignored.
 *   - The order of modifiers and primary key is irrelevant.
 *   - The keystroke parts should be separated by whitespace.
 *   - The keystroke is case sensitive.
 */
export declare function parseKeystroke(keystroke: string): IKeystrokeParts;
/**
 * Normalize a keystroke into a canonical representation.
 *
 * @param keystroke - The keystroke of interest.
 *
 * @returns The normalized representation of the keystroke.
 *
 * #### Notes
 * This normalizes the keystroke by removing duplicate modifiers and
 * extra primary keys, and assembling the parts in a canonical order.
 *
 * The `Cmd` modifier is ignored on non-Mac platforms.
 */
export declare function normalizeKeystroke(keystroke: string): string;
/**
 * Format a keystroke for display on the local system.
 *
 * @param keystroke - The keystroke of interest.
 *
 * @returns The keystroke formatted for display on the local system.
 *
 * #### Notes
 * On Mac, this replaces the modifiers with the Mac-specific unicode
 * characters. On other systems, this joins the modifiers with `+`.
 */
export declare function formatKeystroke(keystroke: string): string;
/**
 * Create a normalized keystroke for a `'keydown'` event.
 *
 * @param event - The event object for a `'keydown'` event.
 *
 * @param layout - The keyboard layout for looking up the primary key.
 *
 * @returns A normalized keystroke, or an empty string if the event
 *   does not represent a valid keystroke for the given layout.
 */
export declare function keystrokeForKeydownEvent(event: KeyboardEvent, layout: IKeyboardLayout): string;
/**
 * An object which represents a key binding.
 *
 * #### Notes
 * Once created, a key binding is immutable.
 */
export declare class KeyBinding {
    /**
     * Construct a new key binding.
     *
     * @param options - The options for initializing the key binding.
     *
     * @throws An error if the key binding selector is invalid.
     *
     * #### Notes
     * The key sequence will be normalized for the platform.
     *
     * If the selector has a comma, only the first clause is used.
     */
    constructor(options: KeyBinding.IOptions);
    /**
     * The key sequence for the key binding.
     *
     * A key sequence is composed of one or more keystrokes, where each
     * keystroke is a combination of modifiers and a primary key.
     *
     * Most key sequences will contain a single keystroke. Key sequences
     * with multiple keystrokes are called "chords", and are useful for
     * implementing modal input (ala Vim).
     *
     * Each keystroke in the sequence should be of the form:
     *   `[<modifier 1> [<modifier 2> [<modifier N> ]]]<primary key>`
     *
     * The supported modifiers are: `Accel`, `Alt`, `Cmd`, `Ctrl`, and
     * `Shift`. The `Accel` modifier is translated to `Cmd` on Mac and
     * `Ctrl` on all other platforms. The `Cmd` modifier is ignored on
     * non-Mac platforms.
     *
     * Keystrokes are case sensitive.
     *
     * **Examples:** `['Accel C']`, `['Shift F11']`, `['D', 'D']`
     */
    keys: string[];
    /**
     * The CSS selector for the key binding.
     *
     * The key binding will only be invoked when the selector matches a
     * node on the propagation path of the keyboard event. This allows
     * the key binding to be restricted to user-defined contexts.
     */
    selector: string;
    /**
     * The command to execute when the key binding is matched.
     */
    command: string;
    /**
     * The arguments for the command.
     */
    args: JSONObject;
    private _keys;
    private _selector;
    private _command;
    private _args;
}
/**
 * The namespace for the `KeyBinding` class statics.
 */
export declare namespace KeyBinding {
    /**
     * An options object for initializing a key binding.
     */
    interface IOptions {
        /**
         * The default key sequence for the key binding.
         */
        keys: string[];
        /**
         * The CSS selector for the key binding.
         */
        selector: string;
        /**
         * The command to execute when the key binding is matched.
         */
        command: string;
        /**
         * The arguments for the command, if necessary.
         */
        args?: JSONObject;
        /**
         * The key sequence to use when running on Windows.
         *
         * If provided, this will override `keys` on Windows platforms.
         */
        winKeys?: string[];
        /**
         * The key sequence to use when running on Mac.
         *
         * If provided, this will override `keys` on Mac platforms.
         */
        macKeys?: string[];
        /**
         * The key sequence to use when running on Linux.
         *
         * If provided, this will override `keys` on Linux platforms.
         */
        linuxKeys?: string[];
    }
}
/**
 * A class which manages a collection of key bindings.
 *
 * #### Notes
 * A singleton instance of this class is all that is necessary for an
 * application, and one is exported from this module as `keymap`.
 */
export declare class KeymapManager {
    /**
     * Construct a new keymap manager.
     */
    constructor();
    /**
     * A signal emitted when a key binding is changed.
     */
    bindingChanged: ISignal<KeymapManager, KeymapManager.IBindingChangedArgs>;
    /**
     * A signal emitted when the keyboard layout has changed.
     */
    layoutChanged: ISignal<KeymapManager, void>;
    /**
     * A read-only sequence of the key bindings in the keymap.
     *
     * #### Notes
     * This is a read-only property.
     */
    bindings: ISequence<KeyBinding>;
    /**
     * Get the keyboard layout used by the keymap.
     *
     * #### Notes
     * The default is a US English layout.
     */
    /**
     * Set the keyboard layout used by the keymap.
     *
     * #### Notes
     * A keymap requires a keyboard layout, so setting this value to
     * `null` will revert the layout to the default US English layout.
     */
    layout: IKeyboardLayout;
    /**
     * Find a key binding which matches the given command and args.
     *
     * @param command - The id of the command of interest.
     *
     * @param args - The arguments for the command.
     *
     * @returns The most recently added key binding which matches the
     *   specified command and args, or `null` if no match is found.
     *
     * #### Notes
     * This is a convenience method which searches through the public
     * sequence of key `bindings`. If custom search behavior is needed,
     * user code may search that sequence manually.
     */
    findKeyBinding(command: string, args: JSONObject): KeyBinding;
    /**
     * Add a key binding to the keymap.
     *
     * @param binding - The key binding to add to the keymap, or an
     *   options object to be converted into a key binding.
     *
     * @returns A disposable which removes the added key binding.
     *
     * #### Notes
     * If multiple key bindings are registered for the same sequence, the
     * binding with the highest selector specificity is executed first. A
     * tie is broken by using the most recently added key binding.
     *
     * Ambiguous key bindings are resolved with a timeout. As an example,
     * suppose two key bindings are registered: one with the key sequence
     * `['Ctrl D']`, and another with `['Ctrl D', 'Ctrl W']`. If the user
     * presses `Ctrl D`, the first binding cannot be immediately executed
     * since the user may intend to complete the chord with `Ctrl W`. For
     * such cases, a timer is used to allow the chord to be completed. If
     * the chord is not completed before the timeout, the first binding
     * is executed.
     */
    addBinding(binding: KeyBinding | KeyBinding.IOptions): IDisposable;
    /**
     * Process a `'keydown'` event and invoke a matching key binding.
     *
     * @param event - The event object for a `'keydown'` event.
     *
     * #### Notes
     * This should be called in response to a `'keydown'` event in order
     * to invoke the command for the best matching key binding.
     *
     * The keymap **does not** install its own key event listeners. This
     * allows the application full control over the nodes for which the
     * keymap processes `'keydown'` events.
     */
    processKeydownEvent(event: KeyboardEvent): void;
    /**
     * Start or restart the pending timeout.
     */
    private _startTimer();
    /**
     * Clear the pending timeout.
     */
    private _clearTimer();
    /**
     * Clear the internal pending state.
     */
    private _clearPendingState();
    /**
     * Replay the events which were suppressed.
     */
    private _replayEvents();
    /**
     * Handle the partial match timeout.
     */
    private _onPendingTimeout();
    private _timerID;
    private _layout;
    private _replaying;
    private _keys;
    private _exact;
    private _events;
    private _bindings;
}
/**
 * The namespace for the `KeymapManager` class statics.
 */
export declare namespace KeymapManager {
    /**
     * An arguments object for the `bindingChanged` signal.
     */
    interface IBindingChangedArgs {
        /**
         * The keybinding which was changed.
         */
        binding: KeyBinding;
        /**
         * Whether the binding was added or removed.
         */
        type: 'added' | 'removed';
    }
}
/**
 * A singleton instance of a `KeymapManager`.
 *
 * #### Notes
 * This singleton instance is all that is necessary for an application.
 * User code will not typically create a new keymap instance.
 */
export declare const keymap: KeymapManager;

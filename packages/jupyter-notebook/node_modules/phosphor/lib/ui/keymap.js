"use strict";
/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
var json_1 = require('../algorithm/json');
var searching_1 = require('../algorithm/searching');
var vector_1 = require('../collections/vector');
var disposable_1 = require('../core/disposable');
var signaling_1 = require('../core/signaling');
var platform_1 = require('../dom/platform');
var selector_1 = require('../dom/selector');
var commands_1 = require('./commands');
var keyboard_1 = require('./keyboard');
/**
 * The timeout in ms for triggering a chord.
 */
var CHORD_TIMEOUT = 1000;
/**
 * Parse a keystroke into its constituent components.
 *
 * @param keystroke - The keystroke of interest.
 *
 * @returns The parsed components of the keystroke.
 *
 * #### Notes
 * The keystroke should be of the form:
 *   `[<modifier 1> [<modifier 2> [<modifier N> ]]]<primary key>`
 *
 * The supported modifiers are: `Accel`, `Alt`, `Cmd`, `Ctrl`, and
 * `Shift`. The `Accel` modifier is translated to `Cmd` on Mac and
 * `Ctrl` on all other platforms.
 *
 * The parsing is tolerant and will not throw exceptions. Notably:
 *   - Duplicate modifiers are ignored.
 *   - Extra primary keys are ignored.
 *   - The order of modifiers and primary key is irrelevant.
 *   - The keystroke parts should be separated by whitespace.
 *   - The keystroke is case sensitive.
 */
function parseKeystroke(keystroke) {
    var key = '';
    var alt = false;
    var cmd = false;
    var ctrl = false;
    var shift = false;
    for (var _i = 0, _a = keystroke.split(/\s+/); _i < _a.length; _i++) {
        var token = _a[_i];
        if (token === 'Accel') {
            if (platform_1.IS_MAC) {
                cmd = true;
            }
            else {
                ctrl = true;
            }
        }
        else if (token === 'Alt') {
            alt = true;
        }
        else if (token === 'Cmd') {
            cmd = true;
        }
        else if (token === 'Ctrl') {
            ctrl = true;
        }
        else if (token === 'Shift') {
            shift = true;
        }
        else if (token.length > 0) {
            key = token;
        }
    }
    return { cmd: cmd, ctrl: ctrl, alt: alt, shift: shift, key: key };
}
exports.parseKeystroke = parseKeystroke;
/**
 * Normalize a keystroke into a canonical representation.
 *
 * @param keystroke - The keystroke of interest.
 *
 * @returns The normalized representation of the keystroke.
 *
 * #### Notes
 * This normalizes the keystroke by removing duplicate modifiers and
 * extra primary keys, and assembling the parts in a canonical order.
 *
 * The `Cmd` modifier is ignored on non-Mac platforms.
 */
function normalizeKeystroke(keystroke) {
    var mods = '';
    var parts = parseKeystroke(keystroke);
    if (parts.ctrl) {
        mods += 'Ctrl ';
    }
    if (parts.alt) {
        mods += 'Alt ';
    }
    if (parts.shift) {
        mods += 'Shift ';
    }
    if (parts.cmd && platform_1.IS_MAC) {
        mods += 'Cmd ';
    }
    return mods + parts.key;
}
exports.normalizeKeystroke = normalizeKeystroke;
/**
 * Format a keystroke for display on the local system.
 *
 * @param keystroke - The keystroke of interest.
 *
 * @returns The keystroke formatted for display on the local system.
 *
 * #### Notes
 * On Mac, this replaces the modifiers with the Mac-specific unicode
 * characters. On other systems, this joins the modifiers with `+`.
 */
function formatKeystroke(keystroke) {
    var mods = '';
    var parts = parseKeystroke(keystroke);
    if (platform_1.IS_MAC) {
        if (parts.ctrl) {
            mods += '\u2303';
        }
        if (parts.alt) {
            mods += '\u2325';
        }
        if (parts.shift) {
            mods += '\u21E7';
        }
        if (parts.cmd) {
            mods += '\u2318';
        }
    }
    else {
        if (parts.ctrl) {
            mods += 'Ctrl+';
        }
        if (parts.alt) {
            mods += 'Alt+';
        }
        if (parts.shift) {
            mods += 'Shift+';
        }
    }
    return mods + parts.key;
}
exports.formatKeystroke = formatKeystroke;
/**
 * Create a normalized keystroke for a `'keydown'` event.
 *
 * @param event - The event object for a `'keydown'` event.
 *
 * @param layout - The keyboard layout for looking up the primary key.
 *
 * @returns A normalized keystroke, or an empty string if the event
 *   does not represent a valid keystroke for the given layout.
 */
function keystrokeForKeydownEvent(event, layout) {
    var key = layout.keyForKeydownEvent(event);
    if (!key) {
        return '';
    }
    var mods = '';
    if (event.ctrlKey) {
        mods += 'Ctrl ';
    }
    if (event.altKey) {
        mods += 'Alt ';
    }
    if (event.shiftKey) {
        mods += 'Shift ';
    }
    if (event.metaKey && platform_1.IS_MAC) {
        mods += 'Cmd ';
    }
    return mods + key;
}
exports.keystrokeForKeydownEvent = keystrokeForKeydownEvent;
/**
 * An object which represents a key binding.
 *
 * #### Notes
 * Once created, a key binding is immutable.
 */
var KeyBinding = (function () {
    /**
     * Construct a new key binding.
     *
     * @param options - The options for initializing the key binding.
     *
     * @throws An error if the key binding selector is invalid.
     *
     * #### Notes
     * The key sequence will be normalized for the platform.
     *
     * If the selector has a comma, only the first clause is used.
     */
    function KeyBinding(options) {
        this._keys = Private.normalizeKeys(options);
        this._selector = Private.normalizeSelector(options);
        this._command = options.command;
        this._args = options.args || null;
    }
    Object.defineProperty(KeyBinding.prototype, "keys", {
        /**
         * The key sequence for the key binding.
         *
         * A key sequence is composed of one or more keystrokes, where each
         * keystroke is a combination of modifiers and a primary key.
         *
         * Most key sequences will contain a single keystroke. Key sequences
         * with multiple keystrokes are called "chords", and are useful for
         * implementing modal input (ala Vim).
         *
         * Each keystroke in the sequence should be of the form:
         *   `[<modifier 1> [<modifier 2> [<modifier N> ]]]<primary key>`
         *
         * The supported modifiers are: `Accel`, `Alt`, `Cmd`, `Ctrl`, and
         * `Shift`. The `Accel` modifier is translated to `Cmd` on Mac and
         * `Ctrl` on all other platforms. The `Cmd` modifier is ignored on
         * non-Mac platforms.
         *
         * Keystrokes are case sensitive.
         *
         * **Examples:** `['Accel C']`, `['Shift F11']`, `['D', 'D']`
         */
        get: function () {
            return this._keys;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KeyBinding.prototype, "selector", {
        /**
         * The CSS selector for the key binding.
         *
         * The key binding will only be invoked when the selector matches a
         * node on the propagation path of the keyboard event. This allows
         * the key binding to be restricted to user-defined contexts.
         */
        get: function () {
            return this._selector;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KeyBinding.prototype, "command", {
        /**
         * The command to execute when the key binding is matched.
         */
        get: function () {
            return this._command;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KeyBinding.prototype, "args", {
        /**
         * The arguments for the command.
         */
        get: function () {
            return this._args;
        },
        enumerable: true,
        configurable: true
    });
    return KeyBinding;
}());
exports.KeyBinding = KeyBinding;
/**
 * A class which manages a collection of key bindings.
 *
 * #### Notes
 * A singleton instance of this class is all that is necessary for an
 * application, and one is exported from this module as `keymap`.
 */
var KeymapManager = (function () {
    /**
     * Construct a new keymap manager.
     */
    function KeymapManager() {
        this._timerID = 0;
        this._layout = keyboard_1.EN_US;
        this._replaying = false;
        this._keys = [];
        this._exact = null;
        this._events = [];
        this._bindings = new vector_1.Vector();
    }
    Object.defineProperty(KeymapManager.prototype, "bindings", {
        /**
         * A read-only sequence of the key bindings in the keymap.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._bindings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KeymapManager.prototype, "layout", {
        /**
         * Get the keyboard layout used by the keymap.
         *
         * #### Notes
         * The default is a US English layout.
         */
        get: function () {
            return this._layout;
        },
        /**
         * Set the keyboard layout used by the keymap.
         *
         * #### Notes
         * A keymap requires a keyboard layout, so setting this value to
         * `null` will revert the layout to the default US English layout.
         */
        set: function (value) {
            value = value || keyboard_1.EN_US;
            if (this._layout === value) {
                return;
            }
            this._layout = value;
            this.layoutChanged.emit(void 0);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Find a key binding which matches the given command and args.
     *
     * @param command - The id of the command of interest.
     *
     * @param args - The arguments for the command.
     *
     * @returns The most recently added key binding which matches the
     *   specified command and args, or `null` if no match is found.
     *
     * #### Notes
     * This is a convenience method which searches through the public
     * sequence of key `bindings`. If custom search behavior is needed,
     * user code may search that sequence manually.
     */
    KeymapManager.prototype.findKeyBinding = function (command, args) {
        var i = searching_1.findLastIndex(this._bindings, function (kb) {
            return kb.command === command && json_1.deepEqual(kb.args, args);
        });
        return i !== -1 ? this._bindings.at(i) : null;
    };
    /**
     * Add a key binding to the keymap.
     *
     * @param binding - The key binding to add to the keymap, or an
     *   options object to be converted into a key binding.
     *
     * @returns A disposable which removes the added key binding.
     *
     * #### Notes
     * If multiple key bindings are registered for the same sequence, the
     * binding with the highest selector specificity is executed first. A
     * tie is broken by using the most recently added key binding.
     *
     * Ambiguous key bindings are resolved with a timeout. As an example,
     * suppose two key bindings are registered: one with the key sequence
     * `['Ctrl D']`, and another with `['Ctrl D', 'Ctrl W']`. If the user
     * presses `Ctrl D`, the first binding cannot be immediately executed
     * since the user may intend to complete the chord with `Ctrl W`. For
     * such cases, a timer is used to allow the chord to be completed. If
     * the chord is not completed before the timeout, the first binding
     * is executed.
     */
    KeymapManager.prototype.addBinding = function (binding) {
        var _this = this;
        // Coerce the binding to an actual `KeyBinding` instance.
        var kb = Private.asKeyBinding(binding);
        // Add the key binding to the internal vector.
        this._bindings.pushBack(kb);
        // Emit the `bindingChanged` signal.
        this.bindingChanged.emit({ binding: kb, type: 'added' });
        // Return a disposable which will remove the binding.
        return new disposable_1.DisposableDelegate(function () {
            // Remove the binding from the vector.
            var i = searching_1.indexOf(_this._bindings, kb);
            if (i !== -1)
                _this._bindings.remove(i);
            // Emit the `bindingChanged` signal.
            _this.bindingChanged.emit({ binding: kb, type: 'removed' });
        });
    };
    /**
     * Process a `'keydown'` event and invoke a matching key binding.
     *
     * @param event - The event object for a `'keydown'` event.
     *
     * #### Notes
     * This should be called in response to a `'keydown'` event in order
     * to invoke the command for the best matching key binding.
     *
     * The keymap **does not** install its own key event listeners. This
     * allows the application full control over the nodes for which the
     * keymap processes `'keydown'` events.
     */
    KeymapManager.prototype.processKeydownEvent = function (event) {
        // Bail immediately if playing back keystrokes.
        if (this._replaying) {
            return;
        }
        // Get the normalized keystroke for the event.
        var keystroke = keystrokeForKeydownEvent(event, this._layout);
        // If the keystroke is not valid for the keyboard layout, replay
        // any suppressed events and clear the pending state.
        if (!keystroke) {
            this._replayEvents();
            this._clearPendingState();
            return;
        }
        // Add the keystroke to the current key sequence.
        this._keys.push(keystroke);
        // Find the exact and partial matches for the key sequence.
        var _a = Private.match(this._bindings, this._keys, event), exact = _a.exact, partial = _a.partial;
        // If there is no exact match and no partial match, replay
        // any suppressed events and clear the pending state.
        if (!exact && !partial) {
            this._replayEvents();
            this._clearPendingState();
            return;
        }
        // Stop propagation of the event. If there is only a partial match,
        // the event will be replayed if a final exact match never occurs.
        event.preventDefault();
        event.stopPropagation();
        // If there is an exact match but no partial match, the exact match
        // can be dispatched immediately. The pending state is cleared so
        // the next key press starts from the default state.
        if (!partial) {
            Private.execute(exact);
            this._clearPendingState();
            return;
        }
        // If there is both an exact match and a partial match, the exact
        // match is stored for future dispatch in case the timer expires
        // before a more specific match is triggered.
        if (exact)
            this._exact = exact;
        // Store the event for possible playback in the future.
        this._events.push(event);
        // (Re)start the timer to dispatch the most recent exact match
        // in case the partial match fails to result in an exact match.
        this._startTimer();
    };
    /**
     * Start or restart the pending timeout.
     */
    KeymapManager.prototype._startTimer = function () {
        var _this = this;
        this._clearTimer();
        this._timerID = setTimeout(function () {
            _this._onPendingTimeout();
        }, CHORD_TIMEOUT);
    };
    /**
     * Clear the pending timeout.
     */
    KeymapManager.prototype._clearTimer = function () {
        if (this._timerID !== 0) {
            clearTimeout(this._timerID);
            this._timerID = 0;
        }
    };
    /**
     * Clear the internal pending state.
     */
    KeymapManager.prototype._clearPendingState = function () {
        this._clearTimer();
        this._exact = null;
        this._keys.length = 0;
        this._events.length = 0;
    };
    /**
     * Replay the events which were suppressed.
     */
    KeymapManager.prototype._replayEvents = function () {
        if (this._events.length === 0) {
            return;
        }
        this._replaying = true;
        this._events.forEach(Private.replayEvent);
        this._replaying = false;
    };
    /**
     * Handle the partial match timeout.
     */
    KeymapManager.prototype._onPendingTimeout = function () {
        this._timerID = 0;
        if (this._exact) {
            Private.execute(this._exact);
        }
        else {
            this._replayEvents();
        }
        this._clearPendingState();
    };
    return KeymapManager;
}());
exports.KeymapManager = KeymapManager;
// Define the signals for the `KeymapManager` class.
signaling_1.defineSignal(KeymapManager.prototype, 'bindingChanged');
signaling_1.defineSignal(KeymapManager.prototype, 'layoutChanged');
/**
 * A singleton instance of a `KeymapManager`.
 *
 * #### Notes
 * This singleton instance is all that is necessary for an application.
 * User code will not typically create a new keymap instance.
 */
exports.keymap = new KeymapManager();
/**
 * The namespace for the private module data.
 */
var Private;
(function (Private) {
    /**
     * Get the platform-specific normalized keys for an options object.
     *
     * The normalized keys are frozen to prevent further modification.
     */
    function normalizeKeys(options) {
        var keys;
        if (platform_1.IS_WIN) {
            keys = options.winKeys || options.keys;
        }
        else if (platform_1.IS_MAC) {
            keys = options.macKeys || options.keys;
        }
        else {
            keys = options.linuxKeys || options.keys;
        }
        return Object.freeze(keys.map(normalizeKeystroke));
    }
    Private.normalizeKeys = normalizeKeys;
    /**
     * Normalize the selector for an options object.
     *
     * This returns the validated first clause of the selector.
     */
    function normalizeSelector(options) {
        return selector_1.validateSelector(options.selector.split(',', 1)[0]);
    }
    Private.normalizeSelector = normalizeSelector;
    /**
     * A coerce a key binding or options into a real key binding.
     */
    function asKeyBinding(value) {
        return value instanceof KeyBinding ? value : new KeyBinding(value);
    }
    Private.asKeyBinding = asKeyBinding;
    /**
     * Find the bindings which match a key sequence.
     *
     * This returns a match result which contains the best exact matching
     * binding, and a flag which indicates if there are partial matches.
     */
    function match(bindings, keys, event) {
        // Whether a partial match has been found.
        var partial = false;
        // The current best exact match.
        var exact = null;
        // The match distance for the exact match.
        var distance = Infinity;
        // The specificity for the exact match.
        var specificity = 0;
        // Iterate over the bindings and search for the best match.
        for (var i = 0, n = bindings.length; i < n; ++i) {
            // Lookup the current binding.
            var binding = bindings.at(i);
            // Check whether the key binding sequence is a match.
            var sqm = matchSequence(binding.keys, keys);
            // If there is no match, the binding is ignored.
            if (sqm === 0 /* None */) {
                continue;
            }
            // If it is a partial match and no other partial match has been
            // found, ensure the selector matches and set the partial flag.
            if (sqm === 2 /* Partial */) {
                if (!partial && targetDistance(binding.selector, event) !== -1) {
                    partial = true;
                }
                continue;
            }
            // Ignore the match if the selector doesn't match, or if the
            // matched node is farther away than the current best match.
            var td = targetDistance(binding.selector, event);
            if (td === -1 || td > distance) {
                continue;
            }
            // Get the specificity for the selector.
            var sp = selector_1.calculateSpecificity(binding.selector);
            // Update the best match if this match is stronger.
            if (exact === null || td < distance || sp >= specificity) {
                exact = binding;
                distance = td;
                specificity = sp;
            }
        }
        // Return the match result.
        return { exact: exact, partial: partial };
    }
    Private.match = match;
    /**
     * Execute the command for the given key binding.
     *
     * If the command is disabled, a message will be logged.
     */
    function execute(binding) {
        var command = binding.command, args = binding.args;
        if (commands_1.commands.isEnabled(command, args)) {
            commands_1.commands.execute(command, args);
        }
        else {
            // TODO - right way to handle disabled command?
            var formatted = binding.keys.map(formatKeystroke).join(' ');
            console.log("'Command '" + command + "' is disabled (" + formatted + ")");
        }
    }
    Private.execute = execute;
    /**
     * Replay a keyboard event.
     *
     * This synthetically dispatches a clone of the keyboard event.
     */
    function replayEvent(event) {
        event.target.dispatchEvent(cloneKeyboardEvent(event));
    }
    Private.replayEvent = replayEvent;
    ;
    /**
     * Test whether a binding sequence matches a key sequence.
     *
     * Returns a `SequenceMatch` value indicating the type of match.
     */
    function matchSequence(bindKeys, userKeys) {
        if (bindKeys.length < userKeys.length) {
            return 0 /* None */;
        }
        for (var i = 0, n = userKeys.length; i < n; ++i) {
            if (bindKeys[i] !== userKeys[i]) {
                return 0 /* None */;
            }
        }
        if (bindKeys.length > userKeys.length) {
            return 2 /* Partial */;
        }
        return 1 /* Exact */;
    }
    /**
     * Find the distance from the target node to the first matching node.
     *
     * This traverses the event path from `target` to `currentTarget` and
     * computes the distance from `target` to the first node which matches
     * the CSS selector. If no match is found, `-1` is returned.
     */
    function targetDistance(selector, event) {
        var distance = 0;
        var target = event.target;
        var current = event.currentTarget;
        for (; target !== null; target = target.parentElement, ++distance) {
            if (selector_1.matchesSelector(target, selector)) {
                return distance;
            }
            if (target === current) {
                return -1;
            }
        }
        return -1;
    }
    /**
     * Clone a keyboard event.
     */
    function cloneKeyboardEvent(event) {
        // A custom event is required because Chrome nulls out the
        // `keyCode` field in user-generated `KeyboardEvent` types.
        var clone = document.createEvent('Event');
        var bubbles = event.bubbles || true;
        var cancelable = event.cancelable || true;
        clone.initEvent(event.type || 'keydown', bubbles, cancelable);
        clone.key = event.key || '';
        clone.keyCode = event.keyCode || 0;
        clone.which = event.keyCode || 0;
        clone.ctrlKey = event.ctrlKey || false;
        clone.altKey = event.altKey || false;
        clone.shiftKey = event.shiftKey || false;
        clone.metaKey = event.metaKey || false;
        clone.view = event.view || window;
        return clone;
    }
})(Private || (Private = {}));

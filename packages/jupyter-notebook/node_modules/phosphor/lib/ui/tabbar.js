"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
var iteration_1 = require('../algorithm/iteration');
var mutation_1 = require('../algorithm/mutation');
var searching_1 = require('../algorithm/searching');
var vector_1 = require('../collections/vector');
var signaling_1 = require('../core/signaling');
var cursor_1 = require('../dom/cursor');
var query_1 = require('../dom/query');
var title_1 = require('./title');
var widget_1 = require('./widget');
/**
 * The class name added to TabBar instances.
 */
var TAB_BAR_CLASS = 'p-TabBar';
/**
 * The class name added to a tab bar body node.
 */
var BODY_CLASS = 'p-TabBar-body';
/**
 * The class name added to a tab bar header node.
 */
var HEADER_CLASS = 'p-TabBar-header';
/**
 * The class name added to a tab bar content node.
 */
var CONTENT_CLASS = 'p-TabBar-content';
/**
 * The class name added to a tab bar footer node.
 */
var FOOTER_CLASS = 'p-TabBar-footer';
/**
 * The class name added to a tab bar tab.
 */
var TAB_CLASS = 'p-TabBar-tab';
/**
 * The class name added to a tab label node.
 */
var LABEL_CLASS = 'p-TabBar-tabLabel';
/**
 * The class name added to a tab icon node.
 */
var ICON_CLASS = 'p-TabBar-tabIcon';
/**
 * The class name added to a tab close icon node.
 */
var CLOSE_ICON_CLASS = 'p-TabBar-tabCloseIcon';
/**
 * The class name added to a tab bar and tab when dragging.
 */
var DRAGGING_CLASS = 'p-mod-dragging';
/**
 * The class name added to the current tab.
 */
var CURRENT_CLASS = 'p-mod-current';
/**
 * The class name added to a closable tab.
 */
var CLOSABLE_CLASS = 'p-mod-closable';
/**
 * The start drag distance threshold.
 */
var DRAG_THRESHOLD = 5;
/**
 * The detach distance threshold.
 */
var DETACH_THRESHOLD = 20;
/**
 * The tab transition duration.
 */
var TRANSITION_DURATION = 150; // Keep in sync with CSS.
/**
 * A widget which displays titles as a row of tabs.
 */
var TabBar = (function (_super) {
    __extends(TabBar, _super);
    /**
     * Construct a new tab bar.
     *
     * @param options - The options for initializing the tab bar.
     */
    function TabBar(options) {
        if (options === void 0) { options = {}; }
        _super.call(this, { node: Private.createNode() });
        this._currentIndex = -1;
        this._titles = new vector_1.Vector();
        this._dirtyTitles = new Set();
        this._tabs = new vector_1.Vector();
        this._dragData = null;
        this.addClass(TAB_BAR_CLASS);
        this.setFlag(widget_1.WidgetFlag.DisallowLayout);
        this._tabsMovable = options.tabsMovable || false;
        this._renderer = options.renderer || TabBar.defaultRenderer;
    }
    /**
     * Dispose of the resources held by the widget.
     */
    TabBar.prototype.dispose = function () {
        this._releaseMouse();
        this._tabs.clear();
        this._titles.clear();
        this._dirtyTitles.clear();
        this._renderer = null;
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(TabBar.prototype, "headerNode", {
        /**
         * Get the tab bar header node.
         *
         * #### Notes
         * This node can be used to add extra content to the tab bar header.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(HEADER_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "bodyNode", {
        /**
         * Get the tab bar body node.
         *
         * #### Notes
         * This node can be used to add extra content to the tab bar.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(BODY_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "footerNode", {
        /**
         * Get the tab bar footer node.
         *
         * #### Notes
         * This node can be used to add extra content to the tab bar footer.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(FOOTER_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "contentNode", {
        /**
         * Get the tab bar content node.
         *
         * #### Notes
         * This is the node which holds the tab nodes.
         *
         * Modifying this node directly can lead to undefined behavior.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(CONTENT_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "titles", {
        /**
         * A read-only sequence of the titles in the tab bar.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._titles;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "currentTitle", {
        /**
         * Get the currently selected title.
         *
         * #### Notes
         * This will be `null` if no tab is selected.
         */
        get: function () {
            var i = this._currentIndex;
            return i !== -1 ? this._titles.at(i) : null;
        },
        /**
         * Set the currently selected title.
         *
         * #### Notes
         * If the title does not exist, the title will be set to `null`.
         */
        set: function (value) {
            this.currentIndex = searching_1.indexOf(this._titles, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "currentIndex", {
        /**
         * Get the index of the currently selected tab.
         *
         * #### Notes
         * This will be `-1` if no tab is selected.
         */
        get: function () {
            return this._currentIndex;
        },
        /**
         * Set the index of the currently selected tab.
         *
         * #### Notes
         * If the value is out of range, the index will be set to `-1`.
         */
        set: function (value) {
            // Coerce the value to an index.
            var i = Math.floor(value);
            if (i < 0 || i >= this._titles.length) {
                i = -1;
            }
            // Bail early if the index will not change.
            if (this._currentIndex === i) {
                return;
            }
            // Look up the previous index and title.
            var pi = this._currentIndex;
            var pt = pi === -1 ? null : this._titles.at(pi);
            // Look up the current index and title.
            var ci = i;
            var ct = ci === -1 ? null : this._titles.at(ci);
            // Update the current index.
            this._currentIndex = i;
            // Emit the current changed signal.
            this.currentChanged.emit({
                previousIndex: pi, previousTitle: pt,
                currentIndex: ci, currentTitle: ct
            });
            // Schedule an update of the tabs.
            this.update();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "tabsMovable", {
        /**
         * Get whether the tabs are movable by the user.
         *
         * #### Notes
         * Tabs can be moved programmatically, irrespective of this value.
         */
        get: function () {
            return this._tabsMovable;
        },
        /**
         * Set whether the tabs are movable by the user.
         *
         * #### Notes
         * Tabs can be moved programmatically, irrespective of this value.
         */
        set: function (value) {
            this._tabsMovable = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "renderer", {
        /**
         * The renderer used by the tab bar
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._renderer;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add a tab to the end of the tab bar.
     *
     * @param value - The title which holds the data for the tab,
     *   or an options object to convert to a title.
     *
     * @returns The title object added to the tab bar.
     *
     * #### Notes
     * If the title is already added to the tab bar, it will be moved.
     */
    TabBar.prototype.addTab = function (value) {
        return this.insertTab(this._titles.length, value);
    };
    /**
     * Insert a tab into the tab bar at the specified index.
     *
     * @param index - The index at which to insert the tab.
     *
     * @param value - The title which holds the data for the tab,
     *   or an options object to convert to a title.
     *
     * @returns The title object added to the tab bar.
     *
     * #### Notes
     * The index will be clamped to the bounds of the tabs.
     *
     * If the title is already added to the tab bar, it will be moved.
     */
    TabBar.prototype.insertTab = function (index, value) {
        // Release the mouse before making any changes.
        this._releaseMouse();
        // Coerce the value to a title.
        var title = Private.asTitle(value);
        // Look up the index of the title.
        var i = searching_1.indexOf(this._titles, title);
        // Clamp the insert index to the vector bounds.
        var j = Math.max(0, Math.min(Math.floor(index), this._titles.length));
        // If the title is not in the vector, insert it.
        if (i === -1) {
            // Create the new tab node for the title.
            var tab = this._renderer.createTabNode();
            this._renderer.updateTabNode(tab, title);
            // Insert the tab and title into the vectors.
            this._tabs.insert(j, tab);
            this._titles.insert(j, title);
            // Look up the next sibling node.
            var ref_1 = j + 1 < this._tabs.length ? this._tabs.at(j + 1) : null;
            // Insert the tab into the content node.
            this.contentNode.insertBefore(tab, ref_1);
            // Connect to the title changed signal.
            title.changed.connect(this._onTitleChanged, this);
            // Update the current index.
            if (this._currentIndex === -1) {
                this._currentIndex = j;
                this.currentChanged.emit({
                    previousIndex: -1, previousTitle: null,
                    currentIndex: j, currentTitle: title
                });
            }
            else if (this._currentIndex >= j) {
                this._currentIndex++;
            }
            // Schedule an update of the tabs.
            this.update();
            // Return the title added to the tab bar.
            return title;
        }
        // Otherwise, the title exists in the vector and should be moved.
        // Adjust the index if the location is at the end of the vector.
        if (j === this._titles.length)
            j--;
        // Bail if there is no effective move.
        if (i === j)
            return title;
        // Move the tab and title to the new locations.
        mutation_1.move(this._tabs, i, j);
        mutation_1.move(this._titles, i, j);
        // Look up the next sibling node.
        var ref = j + 1 < this._tabs.length ? this._tabs.at(j + 1) : null;
        // Move the tab in the content node.
        this.contentNode.insertBefore(this._tabs.at(j), ref);
        // Update the current index.
        var ci = this._currentIndex;
        if (ci === i) {
            this._currentIndex = j;
        }
        else if (ci < i && ci >= j) {
            this._currentIndex++;
        }
        else if (ci > i && ci <= j) {
            this._currentIndex--;
        }
        // Schedule an update of the tabs.
        this.update();
        // Return the title added to the tab bar.
        return title;
    };
    /**
     * Remove a tab from the tab bar.
     *
     * @param value - The title to remove or the index thereof.
     *
     * #### Notes
     * This is a no-op if the title is not contained in the tab bar.
     */
    TabBar.prototype.removeTab = function (value) {
        // Coerce the value to an index.
        var index;
        if (typeof value === 'number') {
            index = value;
        }
        else {
            index = searching_1.indexOf(this._titles, value);
        }
        // Bail if the index is out of range.
        var i = Math.floor(index);
        if (i < 0 || i >= this._titles.length) {
            return;
        }
        // Release the mouse before making any changes.
        this._releaseMouse();
        // Look up the tab and title.
        var tab = this._tabs.at(i);
        var title = this._titles.at(i);
        // Remove the tab and title from the vectors.
        this._tabs.remove(i);
        this._titles.remove(i);
        // Remove the title from the dirty set.
        this._dirtyTitles.delete(title);
        // Disconnect from the title changed signal.
        title.changed.disconnect(this._onTitleChanged, this);
        // Remove the tab from the content node.
        this.contentNode.removeChild(tab);
        // Update the current index.
        if (this._currentIndex === i) {
            var ci = Math.min(i, this._titles.length - 1);
            var ct = ci === -1 ? null : this._titles.at(ci);
            this._currentIndex = ci;
            this.currentChanged.emit({
                previousIndex: i, previousTitle: title,
                currentIndex: ci, currentTitle: ct
            });
        }
        else if (this._currentIndex > i) {
            this._currentIndex--;
        }
        // Schedule an update of the tabs.
        this.update();
    };
    /**
     * Remove all tabs from the tab bar.
     */
    TabBar.prototype.clearTabs = function () {
        var _this = this;
        // Bail if there is nothing to remove.
        if (this._titles.length === 0) {
            return;
        }
        // Release the mouse before making any changes.
        this._releaseMouse();
        // Disconnect from the title changed signals.
        iteration_1.each(this._titles, function (title) {
            title.changed.disconnect(_this._onTitleChanged, _this);
        });
        // Get the current index and title.
        var pi = this.currentIndex;
        var pt = this.currentTitle;
        // Reset the current index.
        this._currentIndex = -1;
        // Clear the tab and title vectors.
        this._tabs.clear();
        this._titles.clear();
        // Clear the dirty title set.
        this._dirtyTitles.clear();
        // Clear the content node.
        this.contentNode.textContent = '';
        // If no tab was selected, there's nothing else to do.
        if (pi === -1) {
            return;
        }
        // Emit the current changed signal.
        this.currentChanged.emit({
            previousIndex: pi, previousTitle: pt,
            currentIndex: -1, currentTitle: null
        });
    };
    /**
     * Release the mouse and restore the non-dragged tab positions.
     *
     * #### Notes
     * This will cause the tab bar to stop handling mouse events and to
     * restore the tabs to their non-dragged positions.
     */
    TabBar.prototype.releaseMouse = function () {
        this._releaseMouse();
    };
    /**
     * Handle the DOM events for the tab bar.
     *
     * @param event - The DOM event sent to the tab bar.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the tab bar's DOM node.
     *
     * This should not be called directly by user code.
     */
    TabBar.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'click':
                this._evtClick(event);
                break;
            case 'mousedown':
                this._evtMouseDown(event);
                break;
            case 'mousemove':
                this._evtMouseMove(event);
                break;
            case 'mouseup':
                this._evtMouseUp(event);
                break;
            case 'keydown':
                this._evtKeyDown(event);
                break;
            case 'contextmenu':
                event.preventDefault();
                event.stopPropagation();
                break;
        }
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    TabBar.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('click', this);
        this.node.addEventListener('mousedown', this);
    };
    /**
     * A message handler invoked on a `'before-detach'` message.
     */
    TabBar.prototype.onBeforeDetach = function (msg) {
        this.node.removeEventListener('click', this);
        this.node.removeEventListener('mousedown', this);
        this._releaseMouse();
    };
    /**
     * A message handler invoked on an `'update-request'` message.
     */
    TabBar.prototype.onUpdateRequest = function (msg) {
        var tabs = this._tabs;
        var titles = this._titles;
        var renderer = this._renderer;
        var dirtyTitles = this._dirtyTitles;
        var currentTitle = this.currentTitle;
        for (var i = 0, n = tabs.length; i < n; ++i) {
            var tab = tabs.at(i);
            var title = titles.at(i);
            if (dirtyTitles.has(title)) {
                renderer.updateTabNode(tab, title);
            }
            if (title === currentTitle) {
                tab.classList.add(CURRENT_CLASS);
                tab.style.zIndex = "" + n;
            }
            else {
                tab.classList.remove(CURRENT_CLASS);
                tab.style.zIndex = "" + (n - i - 1);
            }
        }
        dirtyTitles.clear();
    };
    /**
     * Handle the `'keydown'` event for the tab bar.
     */
    TabBar.prototype._evtKeyDown = function (event) {
        // Stop all input events during drag.
        event.preventDefault();
        event.stopPropagation();
        // Release the mouse if `Escape` is pressed.
        if (event.keyCode === 27)
            this._releaseMouse();
    };
    /**
     * Handle the `'click'` event for the tab bar.
     */
    TabBar.prototype._evtClick = function (event) {
        // Do nothing if it's not a left click.
        if (event.button !== 0) {
            return;
        }
        // Do nothing if a drag is in progress.
        if (this._dragData) {
            return;
        }
        // Do nothing if the click is not on a tab.
        var x = event.clientX;
        var y = event.clientY;
        var i = searching_1.findIndex(this._tabs, function (tab) { return query_1.hitTest(tab, x, y); });
        if (i < 0) {
            return;
        }
        // Clicking on a tab stops the event propagation.
        event.preventDefault();
        event.stopPropagation();
        // Ignore the click if the title is not closable.
        var title = this._titles.at(i);
        if (!title.closable) {
            return;
        }
        // Ignore the click if it was not on a close icon.
        var icon = this._renderer.closeIconNode(this._tabs.at(i));
        if (!icon || !icon.contains(event.target)) {
            return;
        }
        // Emit the tab close requested signal.
        this.tabCloseRequested.emit({ index: i, title: title });
    };
    /**
     * Handle the `'mousedown'` event for the tab bar.
     */
    TabBar.prototype._evtMouseDown = function (event) {
        // Do nothing if it's not a left mouse press.
        if (event.button !== 0) {
            return;
        }
        // Do nothing if a drag is in progress.
        if (this._dragData) {
            return;
        }
        // Do nothing if the press is not on a tab.
        var x = event.clientX;
        var y = event.clientY;
        var i = searching_1.findIndex(this._tabs, function (tab) { return query_1.hitTest(tab, x, y); });
        if (i < 0) {
            return;
        }
        // Pressing on a tab stops the event propagation.
        event.preventDefault();
        event.stopPropagation();
        // Ignore the press if it was on a close icon.
        var icon = this._renderer.closeIconNode(this._tabs.at(i));
        if (icon && icon.contains(event.target)) {
            return;
        }
        // Setup the drag data if the tabs are movable.
        if (this._tabsMovable) {
            this._dragData = new Private.DragData();
            this._dragData.index = i;
            this._dragData.tab = this._tabs.at(i);
            this._dragData.pressX = event.clientX;
            this._dragData.pressY = event.clientY;
            document.addEventListener('mousemove', this, true);
            document.addEventListener('mouseup', this, true);
            document.addEventListener('keydown', this, true);
            document.addEventListener('contextmenu', this, true);
        }
        // Update the current index.
        this.currentIndex = i;
    };
    /**
     * Handle the `'mousemove'` event for the tab bar.
     */
    TabBar.prototype._evtMouseMove = function (event) {
        // Do nothing if no drag is in progress.
        if (!this._dragData) {
            return;
        }
        // Suppress the event during a drag.
        event.preventDefault();
        event.stopPropagation();
        // Check the threshold if the drag is not active.
        var data = this._dragData;
        if (!data.dragActive) {
            // Bail if the drag threshold is not exceeded.
            var dx = Math.abs(event.clientX - data.pressX);
            var dy = Math.abs(event.clientY - data.pressY);
            if (dx < DRAG_THRESHOLD && dy < DRAG_THRESHOLD) {
                return;
            }
            // Fill in the rest of the drag data measurements.
            var tabRect = data.tab.getBoundingClientRect();
            data.tabLeft = data.tab.offsetLeft;
            data.tabWidth = tabRect.width;
            data.tabPressX = data.pressX - tabRect.left;
            data.tabLayout = Private.snapTabLayout(this._tabs);
            data.contentRect = this.contentNode.getBoundingClientRect();
            data.override = cursor_1.overrideCursor('default');
            // Add the dragging style classes.
            data.tab.classList.add(DRAGGING_CLASS);
            this.addClass(DRAGGING_CLASS);
            // Mark the drag as active.
            data.dragActive = true;
        }
        // Emit the detach requested signal if the threshold is exceeded.
        if (!data.detachRequested && Private.detachExceeded(data, event)) {
            // Only emit the signal once per drag cycle.
            data.detachRequested = true;
            // Setup the arguments for the signal.
            var index = data.index;
            var clientX = event.clientX;
            var clientY = event.clientY;
            var title = this._titles.at(index);
            // Emit the tab detach requested signal.
            this.tabDetachRequested.emit({ index: index, title: title, clientX: clientX, clientY: clientY });
            // Bail if the signal handler aborted the drag.
            if (data.dragAborted) {
                return;
            }
        }
        // Update the positions of the tabs.
        Private.layoutTabs(this._tabs, data, event);
    };
    /**
     * Handle the `'mouseup'` event for the tab bar.
     */
    TabBar.prototype._evtMouseUp = function (event) {
        var _this = this;
        // Do nothing if it's not a left mouse release.
        if (event.button !== 0) {
            return;
        }
        // Do nothing if no drag is in progress.
        if (!this._dragData) {
            return;
        }
        // Suppress the event during a drag operation.
        event.preventDefault();
        event.stopPropagation();
        // Remove the extra mouse event listeners.
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
        document.removeEventListener('keydown', this, true);
        document.removeEventListener('contextmenu', this, true);
        // Bail early if the drag is not active.
        var data = this._dragData;
        if (!data.dragActive) {
            this._dragData = null;
            return;
        }
        // Position the tab at its final resting position.
        Private.finalizeTabPosition(data);
        // Remove the dragging class from the tab so it can be transitioned.
        data.tab.classList.remove(DRAGGING_CLASS);
        // Complete the release on a timer to allow the tab to transition.
        setTimeout(function () {
            // Do nothing if the drag has been aborted.
            if (data.dragAborted) {
                return;
            }
            // Clear the drag data reference.
            _this._dragData = null;
            // Reset the positions of the tabs.
            Private.resetTabPositions(_this._tabs);
            // Clear the cursor grab.
            data.override.dispose();
            // Remove the remaining dragging style.
            _this.removeClass(DRAGGING_CLASS);
            // If the tab was not moved, there is nothing else to do.
            var i = data.index;
            var j = data.targetIndex;
            if (j === -1 || i === j) {
                return;
            }
            // Move the tab and title to the new locations.
            mutation_1.move(_this._tabs, i, j);
            mutation_1.move(_this._titles, i, j);
            // Look up the next sibling node.
            var ref = j + 1 < _this._tabs.length ? _this._tabs.at(j + 1) : null;
            // Move the tab in the content node.
            _this.contentNode.insertBefore(_this._tabs.at(j), ref);
            // Update the current index.
            var ci = _this._currentIndex;
            if (ci === i) {
                _this._currentIndex = j;
            }
            else if (ci < i && ci >= j) {
                _this._currentIndex++;
            }
            else if (ci > i && ci <= j) {
                _this._currentIndex--;
            }
            // Emit the tab moved signal.
            _this.tabMoved.emit({
                fromIndex: i, toIndex: j, title: _this._titles.at(j)
            });
            // Schedule an update of the tabs.
            _this.update();
        }, TRANSITION_DURATION);
    };
    /**
     * Release the mouse and restore the non-dragged tab positions.
     */
    TabBar.prototype._releaseMouse = function () {
        // Do nothing if no drag is in progress.
        if (!this._dragData) {
            return;
        }
        // Remove the extra mouse listeners.
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
        document.removeEventListener('keydown', this, true);
        document.removeEventListener('contextmenu', this, true);
        // Clear the drag data reference.
        var data = this._dragData;
        this._dragData = null;
        // Indicate the drag has been aborted. This allows the mouse
        // event handlers to return early when the drag is canceled.
        data.dragAborted = true;
        // If the drag is not active, there's nothing more to do.
        if (!data.dragActive) {
            return;
        }
        // Reset the tabs to their non-dragged positions.
        Private.resetTabPositions(this._tabs);
        // Clear the cursor override.
        data.override.dispose();
        // Clear the dragging style classes.
        data.tab.classList.remove(DRAGGING_CLASS);
        this.removeClass(DRAGGING_CLASS);
    };
    /**
     * Handle the `changed` signal of a title object.
     */
    TabBar.prototype._onTitleChanged = function (sender) {
        this._dirtyTitles.add(sender);
        this.update();
    };
    return TabBar;
}(widget_1.Widget));
exports.TabBar = TabBar;
// Define the signals for the `TabBar` class.
signaling_1.defineSignal(TabBar.prototype, 'currentChanged');
signaling_1.defineSignal(TabBar.prototype, 'tabMoved');
signaling_1.defineSignal(TabBar.prototype, 'tabCloseRequested');
signaling_1.defineSignal(TabBar.prototype, 'tabDetachRequested');
/**
 * The namespace for the `TabBar` class statics.
 */
var TabBar;
(function (TabBar) {
    /**
     * The default implementation of `IRenderer`.
     */
    var Renderer = (function () {
        function Renderer() {
        }
        /**
         * Create a node for a tab.
         *
         * @returns A new node for a tab.
         */
        Renderer.prototype.createTabNode = function () {
            var node = document.createElement('li');
            var icon = document.createElement('div');
            var label = document.createElement('div');
            var close = document.createElement('div');
            node.className = TAB_CLASS;
            icon.className = ICON_CLASS;
            label.className = LABEL_CLASS;
            close.className = CLOSE_ICON_CLASS;
            node.appendChild(icon);
            node.appendChild(label);
            node.appendChild(close);
            return node;
        };
        /**
         * Update a tab node to reflect the state of a title.
         *
         * @param node - A node created by a call to `createTabNode`.
         *
         * @param title - The title object holding the data for the tab.
         */
        Renderer.prototype.updateTabNode = function (node, title) {
            var tabInfix = title.className ? " " + title.className : '';
            var tabSuffix = title.closable ? " " + CLOSABLE_CLASS : '';
            var iconSuffix = title.icon ? " " + title.icon : '';
            var icon = node.firstChild;
            var label = icon.nextSibling;
            node.className = TAB_CLASS + " " + tabInfix + " " + tabSuffix;
            icon.className = ICON_CLASS + " " + iconSuffix;
            label.textContent = title.label;
            label.title = title.caption;
        };
        /**
         * Look up the close icon descendant node for a tab node.
         *
         * @param node - A node created by a call to `createTabNode`.
         *
         * @returns The close icon node, or `null` if none exists.
         */
        Renderer.prototype.closeIconNode = function (node) {
            return node.lastChild;
        };
        return Renderer;
    }());
    TabBar.Renderer = Renderer;
    /**
     * The default `Renderer` instance.
     */
    TabBar.defaultRenderer = new Renderer();
})(TabBar = exports.TabBar || (exports.TabBar = {}));
/**
 * The namespace for the private module data.
 */
var Private;
(function (Private) {
    /**
     * A struct which holds the drag data for a tab bar.
     */
    var DragData = (function () {
        function DragData() {
            /**
             * The tab node being dragged.
             */
            this.tab = null;
            /**
             * The index of the tab being dragged.
             */
            this.index = -1;
            /**
             * The offset left of the tab being dragged.
             */
            this.tabLeft = -1;
            /**
             * The offset width of the tab being dragged.
             */
            this.tabWidth = -1;
            /**
             * The original mouse X position in tab coordinates.
             */
            this.tabPressX = -1;
            /**
             * The tab target index upon mouse release.
             */
            this.targetIndex = -1;
            /**
             * The array of tab layout objects snapped at drag start.
             */
            this.tabLayout = null;
            /**
             * The mouse press client X position.
             */
            this.pressX = -1;
            /**
             * The mouse press client Y position.
             */
            this.pressY = -1;
            /**
             * The bounding client rect of the tab bar content node.
             */
            this.contentRect = null;
            /**
             * The disposable to clean up the cursor override.
             */
            this.override = null;
            /**
             * Whether the drag is currently active.
             */
            this.dragActive = false;
            /**
             * Whether the drag has been aborted.
             */
            this.dragAborted = false;
            /**
             * Whether a detach request as been made.
             */
            this.detachRequested = false;
        }
        return DragData;
    }());
    Private.DragData = DragData;
    /**
     * Create the DOM node for a tab bar.
     */
    function createNode() {
        var node = document.createElement('div');
        var header = document.createElement('div');
        var body = document.createElement('div');
        var footer = document.createElement('div');
        var content = document.createElement('ul');
        header.className = HEADER_CLASS;
        body.className = BODY_CLASS;
        footer.className = FOOTER_CLASS;
        content.className = CONTENT_CLASS;
        body.appendChild(content);
        node.appendChild(header);
        node.appendChild(body);
        node.appendChild(footer);
        return node;
    }
    Private.createNode = createNode;
    /**
     * Coerce a title or options into a real title.
     */
    function asTitle(value) {
        return value instanceof title_1.Title ? value : new title_1.Title(value);
    }
    Private.asTitle = asTitle;
    /**
     * Get a snapshot of the current tab layout values.
     */
    function snapTabLayout(tabs) {
        var layout = new Array(tabs.length);
        for (var i = 0, n = tabs.length; i < n; ++i) {
            var node = tabs.at(i);
            var left = node.offsetLeft;
            var width = node.offsetWidth;
            var cstyle = window.getComputedStyle(node);
            var margin = parseInt(cstyle.marginLeft, 10) || 0;
            layout[i] = { margin: margin, left: left, width: width };
        }
        return layout;
    }
    Private.snapTabLayout = snapTabLayout;
    /**
     * Test if the event exceeds the drag detach threshold.
     */
    function detachExceeded(data, event) {
        var rect = data.contentRect;
        return ((event.clientX < rect.left - DETACH_THRESHOLD) ||
            (event.clientX >= rect.right + DETACH_THRESHOLD) ||
            (event.clientY < rect.top - DETACH_THRESHOLD) ||
            (event.clientY >= rect.bottom + DETACH_THRESHOLD));
    }
    Private.detachExceeded = detachExceeded;
    /**
     * Update the relative tab positions and computed target index.
     */
    function layoutTabs(tabs, data, event) {
        var targetIndex = data.index;
        var targetLeft = event.clientX - data.contentRect.left - data.tabPressX;
        var targetRight = targetLeft + data.tabWidth;
        for (var i = 0, n = tabs.length; i < n; ++i) {
            var style = tabs.at(i).style;
            var layout = data.tabLayout[i];
            var threshold = layout.left + (layout.width >> 1);
            if (i < data.index && targetLeft < threshold) {
                style.left = (data.tabWidth + data.tabLayout[i + 1].margin) + "px";
                targetIndex = Math.min(targetIndex, i);
            }
            else if (i > data.index && targetRight > threshold) {
                style.left = (-data.tabWidth - layout.margin) + "px";
                targetIndex = Math.max(targetIndex, i);
            }
            else if (i === data.index) {
                var ideal = event.clientX - data.pressX;
                var limit = data.contentRect.width - (data.tabLeft + data.tabWidth);
                style.left = Math.max(-data.tabLeft, Math.min(ideal, limit)) + "px";
            }
            else {
                style.left = '';
            }
        }
        data.targetIndex = targetIndex;
    }
    Private.layoutTabs = layoutTabs;
    /**
     * Position the drag tab at its final resting relative position.
     */
    function finalizeTabPosition(data) {
        var ideal;
        if (data.targetIndex === data.index) {
            ideal = 0;
        }
        else if (data.targetIndex > data.index) {
            var tgt = data.tabLayout[data.targetIndex];
            ideal = tgt.left + tgt.width - data.tabWidth - data.tabLeft;
        }
        else {
            var tgt = data.tabLayout[data.targetIndex];
            ideal = tgt.left - data.tabLeft;
        }
        var style = data.tab.style;
        var limit = data.contentRect.width - (data.tabLeft + data.tabWidth);
        style.left = Math.max(-data.tabLeft, Math.min(ideal, limit)) + "px";
    }
    Private.finalizeTabPosition = finalizeTabPosition;
    /**
     * Reset the relative positions of the given tabs.
     */
    function resetTabPositions(tabs) {
        iteration_1.each(tabs, function (tab) { tab.style.left = ''; });
    }
    Private.resetTabPositions = resetTabPositions;
})(Private || (Private = {}));

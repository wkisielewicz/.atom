"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var signaling_1 = require('../core/signaling');
var boxpanel_1 = require('./boxpanel');
var stackedpanel_1 = require('./stackedpanel');
var tabbar_1 = require('./tabbar');
var widget_1 = require('./widget');
/**
 * The class name added to TabPanel instances.
 */
var TAB_PANEL_CLASS = 'p-TabPanel';
/**
 * The class name added to a TabPanel's tab bar.
 */
var TAB_BAR_CLASS = 'p-TabPanel-tabBar';
/**
 * The class name added to a TabPanel's stacked panel.
 */
var STACKED_PANEL_CLASS = 'p-TabPanel-stackedPanel';
/**
 * A widget which combines a `TabBar` and a `StackedPanel`.
 *
 * #### Notes
 * This is a simple panel which handles the common case of a tab bar
 * placed above a content area. The selected tab controls the widget
 * which is shown in the content area.
 *
 * For use cases which require more control than is provided by this
 * panel, the `TabBar` widget may be used independently.
 */
var TabPanel = (function (_super) {
    __extends(TabPanel, _super);
    /**
     * Construct a new tab panel.
     *
     * @param options - The options for initializing the tab panel.
     */
    function TabPanel(options) {
        if (options === void 0) { options = {}; }
        _super.call(this);
        this.addClass(TAB_PANEL_CLASS);
        // Create the tab bar and stacked panel.
        this._tabBar = new tabbar_1.TabBar(options);
        this._tabBar.addClass(TAB_BAR_CLASS);
        this._stackedPanel = new stackedpanel_1.StackedPanel();
        this._stackedPanel.addClass(STACKED_PANEL_CLASS);
        // Connect the tab bar signal handlers.
        this._tabBar.tabMoved.connect(this._onTabMoved, this);
        this._tabBar.currentChanged.connect(this._onCurrentChanged, this);
        this._tabBar.tabCloseRequested.connect(this._onTabCloseRequested, this);
        // Connect the stacked panel signal handlers.
        this._stackedPanel.widgetRemoved.connect(this._onWidgetRemoved, this);
        // Create the box layout.
        var layout = new boxpanel_1.BoxLayout({ direction: 'top-to-bottom', spacing: 0 });
        // Set the stretch factors for the child widgets.
        boxpanel_1.BoxLayout.setStretch(this._tabBar, 0);
        boxpanel_1.BoxLayout.setStretch(this._stackedPanel, 1);
        // Add the child widgets to the layout.
        layout.addWidget(this._tabBar);
        layout.addWidget(this._stackedPanel);
        // Install the layout on the tab panel.
        this.layout = layout;
    }
    /**
     * Dispose of the resources held by the widget.
     */
    TabPanel.prototype.dispose = function () {
        this._tabBar = null;
        this._stackedPanel = null;
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(TabPanel.prototype, "currentIndex", {
        /**
         * Get the index of the currently selected tab.
         *
         * #### Notes
         * This will be `-1` if no tab is selected.
         */
        get: function () {
            return this._tabBar.currentIndex;
        },
        /**
         * Set the index of the currently selected tab.
         *
         * #### Notes
         * If the index is out of range, it will be set to `-1`.
         */
        set: function (value) {
            this._tabBar.currentIndex = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabPanel.prototype, "currentWidget", {
        /**
         * Get the currently selected widget.
         *
         * #### Notes
         * This will be `null` if there is no selected tab.
         */
        get: function () {
            var title = this._tabBar.currentTitle;
            return title ? title.owner : null;
        },
        /**
         * Set the currently selected widget.
         *
         * #### Notes
         * If the widget is not in the panel, it will be set to `null`.
         */
        set: function (value) {
            this._tabBar.currentTitle = value ? value.title : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabPanel.prototype, "tabBar", {
        /**
         * The tab bar associated with the tab panel.
         *
         * #### Notes
         * Modifying the tab bar directly can lead to undefined behavior.
         *
         * This is a read-only property.
         */
        get: function () {
            return this._tabBar;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabPanel.prototype, "stackedPanel", {
        /**
         * The stacked panel associated with the tab panel.
         *
         * #### Notes
         * Modifying the stack directly can lead to undefined behavior.
         *
         * This is a read-only property.
         */
        get: function () {
            return this._stackedPanel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabPanel.prototype, "widgets", {
        /**
         * A read-only sequence of the widgets in the panel.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._stackedPanel.widgets;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add a widget to the end of the tab panel.
     *
     * @param widget - The widget to add to the tab panel.
     *
     * #### Notes
     * If the widget is already contained in the panel, it will be moved.
     *
     * The widget's `title` is used to populate the tab.
     */
    TabPanel.prototype.addWidget = function (widget) {
        this.insertWidget(this.widgets.length, widget);
    };
    /**
     * Insert a widget into the tab panel at a specified index.
     *
     * @param index - The index at which to insert the widget.
     *
     * @param widget - The widget to insert into to the tab panel.
     *
     * #### Notes
     * If the widget is already contained in the panel, it will be moved.
     *
     * The widget's `title` is used to populate the tab.
     */
    TabPanel.prototype.insertWidget = function (index, widget) {
        if (widget !== this.currentWidget)
            widget.hide();
        this._stackedPanel.insertWidget(index, widget);
        this._tabBar.insertTab(index, widget.title);
    };
    /**
     * Handle the `currentChanged` signal from the tab bar.
     */
    TabPanel.prototype._onCurrentChanged = function (sender, args) {
        var previousIndex = args.previousIndex, previousTitle = args.previousTitle, currentIndex = args.currentIndex, currentTitle = args.currentTitle;
        var previousWidget = previousTitle ? previousTitle.owner : null;
        var currentWidget = currentTitle ? currentTitle.owner : null;
        if (previousWidget)
            previousWidget.hide();
        if (currentWidget)
            currentWidget.show();
        if (currentWidget)
            currentWidget.focus();
        this.currentChanged.emit({
            previousIndex: previousIndex, previousWidget: previousWidget, currentIndex: currentIndex, currentWidget: currentWidget
        });
    };
    /**
     * Handle the `tabCloseRequested` signal from the tab bar.
     */
    TabPanel.prototype._onTabCloseRequested = function (sender, args) {
        args.title.owner.close();
    };
    /**
     * Handle the `tabMoved` signal from the tab bar.
     */
    TabPanel.prototype._onTabMoved = function (sender, args) {
        this._stackedPanel.insertWidget(args.toIndex, args.title.owner);
    };
    /**
     * Handle the `widgetRemoved` signal from the stacked panel.
     */
    TabPanel.prototype._onWidgetRemoved = function (sender, widget) {
        this._tabBar.removeTab(widget.title);
    };
    return TabPanel;
}(widget_1.Widget));
exports.TabPanel = TabPanel;
// Define the signals for the `TabPanel` class.
signaling_1.defineSignal(TabPanel.prototype, 'currentChanged');

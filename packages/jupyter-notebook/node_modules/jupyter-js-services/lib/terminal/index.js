// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var json_1 = require('phosphor/lib/algorithm/json');
var signaling_1 = require('phosphor/lib/core/signaling');
var utils = require('../utils');
/**
 * The url for the terminal service.
 */
var TERMINAL_SERVICE_URL = 'api/terminals';
/**
 * The namespace for ITerminalSession statics.
 */
var TerminalSession;
(function (TerminalSession) {
    /**
     * Create a terminal session or connect to an existing session.
     *
     * #### Notes
     * If the session is already running on the client, the existing
     * instance will be returned.
     */
    function open(options) {
        if (options === void 0) { options = {}; }
        if (options.name && options.name in Private.running) {
            return Private.running[options.name];
        }
        return new DefaultTerminalSession(options).connect();
    }
    TerminalSession.open = open;
})(TerminalSession = exports.TerminalSession || (exports.TerminalSession = {}));
/**
 * A terminal session manager.
 */
var TerminalManager = (function () {
    /**
     * Construct a new terminal manager.
     */
    function TerminalManager(options) {
        if (options === void 0) { options = {}; }
        this._baseUrl = '';
        this._wsUrl = '';
        this._ajaxSettings = null;
        this._running = [];
        this._isDisposed = false;
        this._baseUrl = options.baseUrl || utils.getBaseUrl();
        this._wsUrl = options.wsUrl || utils.getWsUrl(this._baseUrl);
        this._ajaxSettings = utils.copy(options.ajaxSettings || {});
    }
    Object.defineProperty(TerminalManager.prototype, "isDisposed", {
        /**
         * Test whether the terminal manager is disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources used by the manager.
     */
    TerminalManager.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        signaling_1.clearSignalData(this);
        this._running = [];
    };
    /**
     * Create a new terminal session or connect to an existing session.
     */
    TerminalManager.prototype.create = function (options) {
        if (options === void 0) { options = {}; }
        options.baseUrl = options.baseUrl || this._baseUrl;
        options.wsUrl = options.wsUrl || this._wsUrl;
        options.ajaxSettings = (options.ajaxSettings || utils.copy(this._ajaxSettings));
        return TerminalSession.open(options);
    };
    /**
     * Shut down a terminal session by name.
     */
    TerminalManager.prototype.shutdown = function (name) {
        var url = utils.urlPathJoin(this._baseUrl, TERMINAL_SERVICE_URL, name);
        var ajaxSettings = utils.copy(this._ajaxSettings || {});
        ajaxSettings.method = 'DELETE';
        return utils.ajaxRequest(url, ajaxSettings).then(function (success) {
            if (success.xhr.status !== 204) {
                return utils.makeAjaxError(success);
            }
        });
    };
    /**
     * Get the list of models for the terminals running on the server.
     */
    TerminalManager.prototype.listRunning = function () {
        var _this = this;
        var url = utils.urlPathJoin(this._baseUrl, TERMINAL_SERVICE_URL);
        var ajaxSettings = utils.copy(this._ajaxSettings || {});
        ajaxSettings.method = 'GET';
        ajaxSettings.dataType = 'json';
        return utils.ajaxRequest(url, ajaxSettings).then(function (success) {
            if (success.xhr.status !== 200) {
                return utils.makeAjaxError(success);
            }
            var data = success.data;
            if (!Array.isArray(data)) {
                return utils.makeAjaxError(success, 'Invalid terminal data');
            }
            if (!json_1.deepEqual(data, _this._running)) {
                _this._running = data.slice();
                _this.runningChanged.emit(data);
            }
            return data;
        });
    };
    return TerminalManager;
}());
exports.TerminalManager = TerminalManager;
/**
 * An implementation of a terminal interface.
 */
var DefaultTerminalSession = (function () {
    /**
     * Construct a new terminal session.
     */
    function DefaultTerminalSession(options) {
        if (options === void 0) { options = {}; }
        this._ajaxSettings = null;
        this._ws = null;
        this._isDisposed = false;
        this._promise = null;
        this._baseUrl = options.baseUrl || utils.getBaseUrl();
        this._ajaxSettings = options.ajaxSettings || {};
        this._name = options.name;
        this._wsUrl = options.wsUrl || utils.getWsUrl(this._baseUrl);
        this._promise = new utils.PromiseDelegate();
    }
    Object.defineProperty(DefaultTerminalSession.prototype, "name", {
        /**
         * Get the name of the terminal session.
         */
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "url", {
        /**
         * Get the websocket url used by the terminal session.
         */
        get: function () {
            return this._url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "isDisposed", {
        /**
         * Test whether the session is disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the session.
     */
    DefaultTerminalSession.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        if (this._ws) {
            this._ws.close();
            this._ws = null;
        }
        delete Private.running[this._name];
        this._promise = null;
        signaling_1.clearSignalData(this);
    };
    /**
     * Send a message to the terminal session.
     */
    DefaultTerminalSession.prototype.send = function (message) {
        var msg = [message.type];
        msg.push.apply(msg, message.content);
        this._ws.send(JSON.stringify(msg));
    };
    /**
     * Shut down the terminal session.
     */
    DefaultTerminalSession.prototype.shutdown = function () {
        var _this = this;
        var url = utils.urlPathJoin(this._baseUrl, TERMINAL_SERVICE_URL, this._name);
        var ajaxSettings = utils.copy(this._ajaxSettings);
        ajaxSettings.method = 'DELETE';
        return utils.ajaxRequest(url, ajaxSettings).then(function (success) {
            if (success.xhr.status !== 204) {
                return utils.makeAjaxError(success);
            }
            _this.dispose();
        });
    };
    /**
     * Connect to the terminal session.
     */
    DefaultTerminalSession.prototype.connect = function () {
        var _this = this;
        if (this._name) {
            return this._initializeSocket();
        }
        return this._getName().then(function (name) {
            _this._name = name;
            return _this._initializeSocket();
        });
    };
    /**
     * Get a name for the terminal from the server.
     */
    DefaultTerminalSession.prototype._getName = function () {
        var url = utils.urlPathJoin(this._baseUrl, TERMINAL_SERVICE_URL);
        var ajaxSettings = utils.copy(this._ajaxSettings);
        ajaxSettings.method = 'POST';
        ajaxSettings.dataType = 'json';
        return utils.ajaxRequest(url, ajaxSettings).then(function (success) {
            if (success.xhr.status !== 200) {
                return utils.makeAjaxError(success);
            }
            return success.data.name;
        });
    };
    /**
     * Connect to the websocket.
     */
    DefaultTerminalSession.prototype._initializeSocket = function () {
        var _this = this;
        var name = this._name;
        Private.running[name] = this._promise.promise;
        this._url = this._wsUrl + "terminals/websocket/" + name;
        this._ws = new WebSocket(this._url);
        this._ws.onmessage = function (event) {
            var data = JSON.parse(event.data);
            _this.messageReceived.emit({
                type: data[0],
                content: data.slice(1)
            });
        };
        this._ws.onopen = function (event) {
            _this._promise.resolve(_this);
        };
        return this._promise.promise;
    };
    return DefaultTerminalSession;
}());
// Define the signals for the `TerminalManager` class.
signaling_1.defineSignal(TerminalManager.prototype, 'runningChanged');
// Define the signals for the `DefaultTerminalSession` class.
signaling_1.defineSignal(DefaultTerminalSession.prototype, 'messageReceived');
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * A mapping of running terminals by name.
     */
    Private.running = Object.create(null);
})(Private || (Private = {}));
